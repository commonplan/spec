parameter_templates:
  - PREC: {range: [1,39]}
  - SCALE: {range: [0,39]}
  - SCALAR_NUMBER: {types: [i8,i16,i32,i64,fp32,fp64]}
  - NUMERIC_OVERFLOW:
    options: [ SILENT, SATURATE, ERROR ]
    required: false
function_templates:
  - name: "comparisons"
    nullability: DECLARED_OUTPUT
    variants:
      - variant: simple
        parameters:
          - K: [ boolean,i8,i16,i32,i64,fp32,fp64,timestamp,timestamp_tz,date,time ]
        arguments:
          - value: K
          - value: K
        return: boolean
      - variant: string comparisons
        parameters:
          - S1: { types: [ "VARCHAR<L1>", "FIXEDCHAR<L1>", "STRING" ] }
          - S2: { types: [ "VARCHAR<L2>", "FIXEDCHAR<L2>", "STRING" ] }
        arguments:
          - value: S1
          - value: S2
        return: boolean
      - variant: binary comparisons
        parameters:
          - S1: { types: [ "BINARY", "FIXEDBINARY<L1>" ] }
          - S1: { types: [ "BINARY", "FIXEDBINARY<L2>" ] }
        arguments:
          - value: S1
          - value: S2
        return: boolean
  - name: boolean
    arugments:
      - value: boolean
      - value: boolean
    return: boolean

functions:
- name: '+'
  description: "Add two numeric values."
    - variant: scalar
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - K: SCALAR_NUMBER
      arguments:
        - enum: overflow
        - type: K
        - type: K
      return: K
    - variant: decimal
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - P1: PREC
        - S1: SCALE
        - P2: PREC
        - S2: SCALE
      arguments:
        - enum: overflow
        - value: "DECIMAL<P1,S1>"
        - value: "DECIMAL<P2,S2>"
      return: |-
        init_scale = max(S1,S2)
        init_prec = init_scale + max(P1 - S1, P2-S2) + 1
        min_scale = min(init_scale, 6)
        delta = init_prec - 38
        prec = min(init_prec,38)
        scale = init_prec > 38 ? scale - init_prec + 38 : min_scale
        DECIMAL<prec, scale>
    - variant: date/time plus interval year
      description: Add an interval to a date/time type.
      parameters:
        - T: [timestamp, timestamp_tz, date]
        - I: [interval_year, interval_day]
      arguments:
        - value: T
        - value: I
      return: T
- name: '-'
  description: "Subtract one operand from another."
  variants:
    - variant: scalar
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - K: SCALAR_NUMBER
      arguments:
        - enum: overflow
        - type: K
        - type: K
      return: K
    - variant: decimal
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - P1: PREC
        - S1: SCALE
        - P2: PREC
        - S2: SCALE
      arguments:
        - enum: overflow
        - value: "DECIMAL<P1,S1>"
        - value: "DECIMAL<P2,S2>"
      return: |-
        init_scale = max(S1,S2)
        init_prec = init_scale + max(P1 - S1, P2-S2) + 1
        min_scale = min(init_scale, 6)
        delta = init_prec - 38
        prec = min(init_prec,38)
        scale = init_prec > 38 ? scale - init_prec + 38 : min_scale
        DECIMAL<prec, scale>
- name: '*'
  description: Multiply two numeric values.
  variants:
    - variant: scalar
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - K: SCALAR_NUMBER
      arguments:
        - enum: overflow
        - type: K
        - type: K
      return: K
    - variant: decimal
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - P1: PREC
        - S1: SCALE
        - P2: PREC
        - S2: SCALE
      arguments:
        - enum: overflow
        - value: "DECIMAL<P1,S1>"
        - value: "DECIMAL<P2,S2>"
      return: |-
        init_scale = S1 + S2
        init_prec = P1 + P2 + 1
        min_scale = min(init_scale, 6)
        delta = init_prec - 38
        prec = min(init_prec,38)
        scale = init_prec > 38 ? scale - init_prec + 38 : min_scale
        DECIMAL<prec, scale>
- name: '/'
  description: "Divide two numeric values."
  variants:
    - variant: scalar
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - K: SCALAR_NUMBER
      arguments:
        - enum: overflow
        - type: K
        - type: K
      return: K
    - variant: decimal
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - P1: PREC
        - S1: SCALE
        - P2: PREC
        - S2: SCALE
      arguments:
        - enum: overflow
        - value: "DECIMAL<P1,S1>"
        - value: "DECIMAL<P2,S2>"
      return: |-
        init_scale = max(6, S1 + P2 + 1)
        init_prec = P1 - S1 + P2 + init_scale
        min_scale = min(init_scale, 6)
        delta = init_prec - 38
        prec = min(init_prec,38)
        scale = init_prec > 38 ? scale - init_prec + 38 : min_scale
        DECIMAL<prec, scale>
- name: ['mod','%']
  description: "Modulus of two values."
  variants:
    - variant: scalar
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - K: SCALAR_NUMBER
      arguments:
        - enum: overflow
        - type: K
        - type: K
      return: K
    - variant: decimal
      parameters:
        - overflow: NUMERIC_OVERFLOW
        - P1: PREC
        - S1: SCALE
        - P2: PREC
        - S2: SCALE
      arguments:
        - enum: overflow
        - value: "DECIMAL<P1,S1>"
        - value: "DECIMAL<P2,S2>"
      return: |-
        init_scale = max(S1,S2)
        init_prec = min(P1 - S1, P2 - S2) + init_scale
        min_scale = min(init_scale, 6)
        delta = init_prec - 38
        prec = min(init_prec,38)
        scale = init_prec > 38 ? scale - init_prec + 38 : min_scale
        DECIMAL<prec, scale>
- name: like
  description: Determine whether a string matches a particular pattern using SQL standard like syntax.
  options:
    case: [SENSITIVE, INSENSITIVE]
  parameters:
    - S1: STRINGS
    - S2: STRINGS
  arguments:
    - type: S1
      name: value to test
    - type: S2
      name: pattern
      constant: true
  return: boolean
- name: "="
  extends: comparisons
  description: Whether two values equal eachother.
  variants:
    - variant: equality_only_types
      parameters:
        - K: {types: [uuid, interval_year, interval_day]}
      arguments:
        - value: K
        - value: K
      return: boolean
- name: "is_not_distinct_from"
  extends: comparisons
  description: Whether two values equal eachother (nulls are considered equal).
  variants:
    - variant: equality_only_types
      parameters:
        - K: {types: [uuid, interval_year, interval_day]}
      arguments:
        - value: K
        - value: K
      return: boolean
- name: ["!=", "<>"]
  extends: comparisons
  description: Whether two values are not equal to eachother.
- name: "<"
  extends: comparisons
  description: Whether the first value is less than the second value.
- name: "<="
  extends: comparisons
  description: Whether the first value is less than or equal to the second value.
- name: ">"
  extends: comparisons
  description: Whether the first value is greater than the second value.
- name: ">="
  extends: comparisons
  description: Whether the first value is greater than or equal to the second value.
- name: compare
  description: |-
    Whether the first value is greater than, less than or equal to the second value. Returns -1 if first
    value is less than second, 0 if the two values are equal or 1 if the first value is greater than the second.
  options:
    nulls: [FIRST, LAST]
  variants:
    - variant: simple
      parameters:
        - K: {types: [boolean,i8,i16,i32,i64,fp32,fp64,timestamp,timestamp_tz,date,time,interval_year]}
      arguments:
        - value: K
        - value: K
      return: i8
    - variant: string comparisons
      parameters:
        - S1: {types: ["VARCHAR<L1>", "FIXEDCHAR<L1>", "STRING"]}
        - S2: {types: ["VARCHAR<L2>", "FIXEDCHAR<L2>", "STRING"]}
      arguments:
        - value: S1
        - value: S2
      return: i8
- name: cast
  description: Convert value from one type to another.
  nullability: DISCRETE
  variants:
    - variant: string
      description: Convert value to string.
      parameters:
        - V: {types: [boolean, i8, i16, i32, i64, fp32, fp64, timestamp_tz, date, time, interval_year, interval_day,
              boolean?, i8?, i16?, i32?, i64?, fp32?, fp64?, timestamp_tz?, date?, time?, interval_year?, interval_day?]}

        - S: {types:[VARCHAR<N>, FIXEDCHAR<N>, STRING, VARCHAR<N>?, FIXEDCHAR<N>?, STRING?]}
      arguments:
        - type: S
          name: Target type.
        - value: V
          name: Value to cast.
- name: extract
  description: Extract portion of a date/time value.
  parameters:
    - D: {types: [timestamp, timestamp_tz, date, time]}
    - date_part:
      options: [ YEAR, MONTH, DAY, SECOND ]
      required: true
  arguments:
    - value: D
      name: Date/time value to extract information from.
    - enum: date_part
      name: The part of the value to extract.
  return: i64
- name: not
  description: The boolean not of a provided value
  arugments:
    - value: boolean
  return: boolean
- name: and
  extends: boolean
  description: The boolean and of two values.
- name: or
  extends: boolean
  description: The boolean or of two values.
- name: xor
  extends: boolean
  description: The boolean xor of two values.
- name: concat
  variants:
      - variant: fixed-width strings
        arguments:
          - value: FIXEDCHAR<L1>
          - value: FIXEDCHAR<L2>
        return: FIXEDCHAR<L1 + L2>
      - variant: variable defined-length strings
        parameters:
          - S1: {types: [FIXEDCHAR<L1>, VARCHAR<L1>]}
          - S2: {types: [FIXEDCHAR<L2>, VARCHAR<L2>]}
        arguments:
          - value: S1
          - value: S2
        return VARCHAR<L1 + L2>
      - variant: arbitrary length values
        parameters:
          - S1: {types: ["VARCHAR<L1>", "FIXEDCHAR<L1>", "STRING"]}
          - S2: {types: ["VARCHAR<L2>", "FIXEDCHAR<L2>", "STRING"]}
        arguments:
          - value: S1
          - value: S2
        return: string
      - variant: fixed-width binary
        arguments:
          - value: FIXEDBINARY<L1>
          - value: FIXEDBINARY<L2>
        return: FIXEDBINARY<L1 + L2>
      - variant: binary
        parameters:
          - S1: {types: [ fixedbinary<L1>, binary ]}
          - S2: {types: [ fixedbinary<L2>, binary ]}
        arguments:
          - value: S1
          - value: S2
        return: binary
- name: substring
  description: Get a sub portion of the given string.
  parameters:
    - S: {types: ["VARCHAR<L>", "FIXEDCHAR<L>", "STRING"]}
  arguments:
    - value: S
      name: String to extract from.
    - value: i32
      name: Start position (inclusive, zero index). Negatives starts from end of string.
    - value: i32
      name: End position (exclusive, zero index). Negative starts from end of string.




